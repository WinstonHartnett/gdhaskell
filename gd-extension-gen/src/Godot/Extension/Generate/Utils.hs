{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE OverloadedLists #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}

module Godot.Extension.Generate.Utils where

import Data.Char (toUpper)
import Data.HashMap.Strict qualified as HM
import Data.Text qualified as T
import GHC.Data.FastString (FastString, mkFastStringShortByteString)

import Control.Monad.IO.Class (MonadIO (liftIO))
import Control.Monad.ST (runST)
import Data.ByteString.Short.Internal qualified as BI
import Data.Maybe (isJust)
import Data.Primitive.ByteArray (ByteArray (ByteArray), cloneByteArray, copyByteArray, copyByteArrayToPtr, freezeByteArray, newByteArray, sizeofByteArray, sizeofMutableByteArray, unsafeFreezeByteArray, unsafeThawByteArray, mutableByteArrayContents)
import Data.Text.Array qualified as TI
import Data.Text.Internal qualified as TI
import Data.Vector qualified as V
import Data.Vector.Algorithms.Heap qualified as V
import Data.Word (Word8)
import Debug.Trace (trace)
import Foreign (Storable (pokeByteOff), free, mallocArray0)
import Foreign.C.String (CString)
import GHC.Exts (Int (I#), sizeofByteArray#)
import GHC.IO (unsafePerformIO)

-- | Mapping from the types in 'Foreign.C.Types' to Haskell-native types.
foreignCToHs :: HM.HashMap T.Text T.Text
foreignCToHs =
  HM.fromList
    [ ("CChar", "Int8")
    , ("CSChar", "Int8")
    , ("CUChar", "Word8")
    , ("CUShort", "Word16")
    , ("CInt", "Int32")
    , ("CUInt", "Word32")
    , ("CULong", "Word64")
    , ("CPtrdiff", "Int64")
    , ("CSize", "Word64")
    , ("CWchar", "Int32")
    , ("CSigAtomic", "Int32")
    , ("CLong", "Int64")
    , ("CLLong", "Int64")
    , ("CULLong", "Word64")
    , ("CBool", "Word8")
    , ("CIntPtr", "Int64")
    , ("CUIntPtr", "Word64")
    , ("CIntMax", "Int64")
    , ("CUIntMax", "Word64")
    , ("CClock", "Int64")
    , ("CTime", "Int64")
    , ("CUSeconds", "Word32")
    , ("CSUSeconds", "Int64")
    , ("CFloat", "Float")
    , ("CDouble", "Double")
    ]

-- | Mapping from native C types to Haskell's 'Foreign.C.Types'.
cToForeignC :: HM.HashMap T.Text T.Text
cToForeignC =
  HM.fromList
    [ ("uint64_t", "CULong")
    , ("uint32_t", "CUInt")
    , ("uint16_t", "CUShort")
    , ("uint8_t", "CUChar")
    , ("int64_t", "CLong")
    , ("int32_t", "CInt")
    , ("int16_t", "CShort")
    , ("int", "CInt")
    , ("wchar_t", "CInt")
    , ("char", "CChar")
    , ("size_t", "CULong")
    , ("float", "CFloat")
    , ("double", "CDouble")
    , ("char16_t", "CUShort")
    , ("char32_t", "CUInt")
    , ("void", "()")
    ]

-- | Substrings to camelize when converting Text to camelcase.
camelSubstitutions :: V.Vector (T.Text, T.Text)
camelSubstitutions =
  V.map
    (\t -> (t, capitalizeFirst $ T.toLower t))
    $ V.modify
      ( V.sortBy
          ( \a b ->
              let aLen = T.length a
                  bLen = T.length b
               in if aLen < bLen
                    then GT
                    else if aLen > bLen then LT else EQ
          )
      )
      [ "GDNative"
      , "AES"
      , "OGG"
      , "AABB"
      , "CPU"
      , "CSG"
      , "DTLS"
      , "GLTF"
      , "GDScript"
      , "GPU"
      , "HTTP"
      , "JSON"
      , "RPC"
      , "JNI"
      , "ORM"
      , "OS"
      , "PCK"
      , "RDA"
      , "RDF"
      , "RD"
      , "RID"
      , "TCP"
      , "UPNP"
      , "RTC"
      , "3D"
      , "2D"
      ]

vIntersperse :: a -> V.Vector a -> V.Vector a
vIntersperse i v =
  let targetLen = (V.length v * 2) - 1
      f n
        | n `mod` 2 == 0 = v V.! (n `div` 2)
        | otherwise = i
   in V.generate targetLen f

capitalizeFirst :: T.Text -> T.Text
capitalizeFirst t =
  if T.null t
    then t
    else (T.singleton . toUpper $ T.head t) <> T.tail t

{- | Convert text from snake_case to camelCase, substituting any substrings in
 'camelSubstitutions' with their camelCase variants.
-}
toCamelCase :: T.Text -> T.Text
toCamelCase t =
  let (first, rest) = T.breakOn "_" t
      splitRest = map capitalizeFirst . filter (not . T.null) $ T.splitOn "_" rest
      replace i =
        V.foldl'
          (\acc (needle, target) -> T.replace needle target acc)
          i
          camelSubstitutions
   in mconcat $ map replace (first : splitRest)

toCapitalCamelCase :: T.Text -> T.Text
toCapitalCamelCase = capitalizeFirst . toCamelCase

autoGenHeader :: T.Text
autoGenHeader = "{- This file was generated by `gd-extension-gen`. -}"

-- | Wrapper function to make a GHC 'FastString' from Text.
fsText :: T.Text -> FastString
fsText (TI.Text (TI.ByteArray ba#) off len) =
  if off == 0 && I# (sizeofByteArray# ba#) == len
    then mkFastStringShortByteString (BI.SBS ba#)
    else
      mkFastStringShortByteString
        . (\(ByteArray ba'#) -> BI.SBS ba'#)
        $ cloneByteArray (ByteArray ba#) off len
{-# INLINABLE fsText #-}

-- | Marshal text into a temporarily-allocated, NUL-terminated UTF-8 CString.
withUtf8 :: MonadIO m => T.Text -> (CString -> m a) -> m a
withUtf8 (TI.Text (TI.ByteArray ba#) off len) f = do
  arr <- liftIO do
    ptr <- mallocArray0 baSize
    copyByteArrayToPtr ptr ba off len
    pokeByteOff @Word8 ptr baSize 0
    pure ptr
  f arr <* liftIO (free arr)
 where
  ba = ByteArray ba#
  baSize = len - off
{-# INLINEABLE withUtf8 #-}
{-# SPECIALIZE withUtf8 :: T.Text -> (CString -> IO a) -> IO a #-}